import java.io.*;
import java_cup.runtime.*;

action code
{:

    public String repeat(int count, String with) {
        return new String(new char[count]).replace("\0", with);
    }
    public String repeat(int count) {
        return repeat(count, "|    ");
    }
    public void Print(Tree tree, int depth) {
        System.out.println(repeat(depth) + tree.toString());
        Tree[] children = tree.getChildren();
        if (children != null) {
            for (Tree child : children) { 
                if (child != null) {
                    Print(child, depth + 1);
                }
            }
        }
    }

:}

parser code
{:
    public void syntax_error(Symbol s){
        report_error("Error sintactico en linea: " + (s.left + 1) + " y columna: " + (s.right + 1) + "\n El simbolo fue: ", sym.terminalNames[s.sym]);
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        report_fatal_error("Error sintactico fatal: " + s + "\n", null);
    }

:}

terminal COMA, PERIOD;
terminal NOT, AND, OR;
terminal IF, THEN, ELSE, ELSEIF;
terminal DO, LOOP, WHILE;
terminal FOR, TO, NEXT;
terminal MOD;
terminal READLINE, PRINT;
terminal SUB, FUNCTION;
terminal DIM, AS, EQUALTO;
terminal OPENPARENTHESIS, CLOSEPARENTHESIS;
terminal ENDOFLINE;
terminal TRUE, FALSE;
terminal MAIN;
terminal END;
terminal String STRING, ID, TYPE, INTEGER, CHAR;
terminal String RELATIONALOPERATOR, MULTIPLICATIONOPERATOR, ADDITIONOPERATOR;

non terminal Program;
non terminal ModuleListClass PreModuleList, ModuleList;
non terminal FunctionHelper Function;
non terminal ProcedureHelper Procedure;
non terminal ListClass PreArgumentList, ArgumentList;
non terminal ArgumentHelper Argument;
non terminal ListClass PreStatementList, StatementList;
non terminal StatementClass Statement, Loop, IO;
non terminal DeclarationStatement Declaration;
non terminal AssignmentStatement Assignment;
non terminal ListClass ExpressionList;
non terminal Expression Expression;
non terminal FunctionCallStatement FunctionCall;
non terminal ConditionalStatement Conditional;
non terminal ListClass ConditionalElse;
non terminal ForStatement For;
non terminal WhileStatement While;

precedence left AND, OR;
precedence left RELATIONALOPERATOR;
precedence left ADDITIONOPERATOR;
precedence left MULTIPLICATIONOPERATOR, MOD;
precedence left NOT;


start with Program;

Program ::= PreModuleList:list {: Print(list, 0); :}
;

PreModuleList       ::= SUB:sub MAIN OPENPARENTHESIS CLOSEPARENTHESIS ENDOFLINE PreStatementList:slist END SUB ENDOFLINE ModuleList:mlist 
                        {: RESULT = new ModuleListClass(subleft, subright, mlist, new ProcedureHelper(subleft, subright, "Main", null, slist)); :}
                    | Function:func ENDOFLINE PreModuleList:pmlist
                        {: RESULT = new ModuleListClass(func.line, func.column, pmlist, func); :}
                    | Procedure:proc ENDOFLINE PreModuleList:pmlist
                        {: RESULT = new ModuleListClass(proc.line, proc.column, pmlist, proc); :}
                    | Declaration:dec ENDOFLINE PreModuleList:pmlist
                        {: RESULT = new ModuleListClass(dec.line, dec.column, pmlist, dec); :}
;

ModuleList          ::= Function:func ENDOFLINE ModuleList:mlist
                        {: RESULT = new ModuleListClass(func.line, func.column, mlist, func); :}
                    | Procedure:proc ENDOFLINE ModuleList:mlist
                        {: RESULT = new ModuleListClass(proc.line, proc.column, mlist, proc); :}
                    | Declaration:dec ENDOFLINE ModuleList:mlist
                        {: RESULT = new ModuleListClass(dec.line, dec.column, mlist, dec); :}
                    |
                        {: RESULT = null; :}
;

Function            ::= FUNCTION:func ID:id OPENPARENTHESIS ArgumentList:alist CLOSEPARENTHESIS AS TYPE:type ENDOFLINE PreStatementList:pslist END FUNCTION
                        {: RESULT = new FunctionHelper(funcleft, funcright, id, alist, pslist, type); :}
                    | FUNCTION:func ID:id AS TYPE:type ENDOFLINE PreStatementList:pslist END FUNCTION
                        {: RESULT = new FunctionHelper(funcleft, funcright, id, null, pslist, type); :}
;

Procedure           ::= SUB:sub ID:id OPENPARENTHESIS ArgumentList:alist CLOSEPARENTHESIS ENDOFLINE PreStatementList:pslist END SUB
                        {: RESULT = new ProcedureHelper(subleft, subright, id, alist, pslist); :}
                    | SUB:sub ID:id ENDOFLINE PreStatementList:pslist END SUB
                        {: RESULT = new ProcedureHelper(subleft, subright, id, null, pslist); :}
;

PreArgumentList     ::= ArgumentList:alist
                        {: RESULT = alist; :}
                    |
                        {: RESULT = null; :}
;

ArgumentList        ::= Argument:arg COMA ArgumentList:alist 
                        {: 
                            alist.Add(arg);
                            RESULT = alist; 
                        :}
                    | Argument:arg
                        {: RESULT = new ListClass<ArgumentHelper> (arg.line, arg.column, arg); :}
;

Argument            ::= ID:id AS TYPE:type
                        {: RESULT = new ArgumentHelper( idleft, idright, id, type); :}
;

PreStatementList    ::= StatementList:slist
                        {: RESULT = slist; :}
                    |
                        {: RESULT = null; :}
;

StatementList       ::= Statement:stat ENDOFLINE StatementList:slist 
                        {: 
                            slist.Add(stat);
                            RESULT = slist; 
                        :}
                    | Statement:stat ENDOFLINE
                        {: RESULT = new ListClass<StatementClass> (stat.line, stat.column, stat); :}
;

FunctionCall        ::= ID:id OPENPARENTHESIS ExpressionList:elist CLOSEPARENTHESIS
                        {: RESULT = new FunctionCallStatement(idleft, idright, id, elist); :}
                    | ID:id OPENPARENTHESIS CLOSEPARENTHESIS
                        {: RESULT = new FunctionCallStatement(idleft, idright, id, null); :}
;

Statement           ::= Declaration:dec
                        {: RESULT = dec; :}
                    | Assignment:ass
                        {: RESULT = ass; :}
                    | Conditional:cond
                        {: RESULT = cond; :}
                    | Loop:loo
                        {: RESULT = loo; :}
                    | IO:io
                        {: RESULT = io; :}
                    | FunctionCall:func
                        {: RESULT = func; :}
                    |
                        {: RESULT = null; :}
;

Declaration         ::= DIM:dim ID:id AS TYPE:type
                        {: RESULT = new DeclarationStatement(dimleft, dimright, id, type); :}
                    | DIM:dim ID:id AS TYPE:type EQUALTO Expression:exp
                        {: RESULT = new DeclarationStatement(dimleft, dimright, id, type, exp); :}
;

Assignment          ::= ID:id EQUALTO Expression:exp
                        {: RESULT = new AssignmentStatement(idleft, idright, id, exp); :}
;

IO                  ::= PRINT:print Expression:exp
                        {: RESULT =  new WriteStatement(printleft, printright, exp); :}
                    | READLINE:read ID:id
                        {: RESULT = new ReadStatement(readleft, readright, id); :}
;

Conditional         ::= IF:condIf Expression:exp THEN ENDOFLINE PreStatementList:pslist ConditionalElse:condElse END IF
                        {: RESULT = new ConditionalStatement(condIfleft, condIfright, exp, pslist, condElse); :}
                    | IF:condIf Expression:exp THEN ENDOFLINE PreStatementList:pslist END IF
                        {: RESULT = new ConditionalStatement(condIfleft, condIfright, exp, pslist, null); :}
;

ConditionalElse     ::= ELSE ENDOFLINE PreStatementList:pslist
                        {: RESULT = pslist; :}
                    | ELSEIF:cond Expression:exp THEN ENDOFLINE PreStatementList:pslist ConditionalElse:condElse
                        {: RESULT = new ListClass(condleft, condright, new ConditionalStatement(condleft, condright, exp, pslist, condElse)); :}
                    | ELSEIF:cond Expression:exp THEN ENDOFLINE PreStatementList:pslist
                        {: RESULT = new ListClass(condleft, condright, new ConditionalStatement(condleft, condright, exp, pslist, null));  :}
;

Loop                ::= For:fs
                        {: RESULT = fs; :}
                    | While:ws
                        {: RESULT = ws; :}
;

For                 ::= FOR:fs Assignment:ass TO INTEGER:i ENDOFLINE PreStatementList:pslist NEXT
                        {: RESULT = new ForStatement(fsleft, fsright, ass, Integer.parseInt(i), pslist); :}
;

While               ::= DO:d ENDOFLINE PreStatementList:pslist LOOP WHILE Expression:exp
                        {: RESULT = new WhileStatement(dleft, dright, exp, pslist); :}
;

ExpressionList      ::= Expression:exp COMA ExpressionList:elist
                        {:
                            elist.Add(exp);
                            RESULT = elist; 
                        :}
                    | Expression:exp
                        {: RESULT = new ListClass<Expression> (exp.line, exp.column, exp); :}
;

Expression          ::= Expression:expL ADDITIONOPERATOR:opp Expression:expR
                        {: RESULT = new BinaryExpression(expL.line, expL.column, expL, opp, expR); :}
                    | Expression:expL MULTIPLICATIONOPERATOR:opp Expression:expR
                        {: RESULT = new BinaryExpression(expL.line, expL.column, expL, opp, expR); :}
                    | Expression:expL RELATIONALOPERATOR:opp Expression:expR
                        {: RESULT = new BinaryExpression(expL.line, expL.column, expL, opp, expR); :}
                    | Expression:expL AND Expression:expR
                        {: RESULT = new BinaryExpression(expL.line, expL.column, expL, "AND", expR); :}
                    | Expression:expL OR Expression:expR
                        {: RESULT = new BinaryExpression(expL.line, expL.column, expL, "OR", expR); :}
                    | Expression:expL MOD Expression:expR
                        {: RESULT = new BinaryExpression(expL.line, expL.column, expL, "MOD", expR); :}
                    | NOT:not Expression:exp
                        {: RESULT = new UnaryExpression(notleft, notright, "NOT", exp); :}
                    | ID:id
                        {: RESULT = new IdExpression(idleft, idright, id); :}
                    | INTEGER:i
                        {: RESULT = new LiteralExpression<Integer> (ileft, iright, Integer.parseInt(i)); :}
                    | STRING:s
                        {: RESULT = new LiteralExpression<String> (sleft, sright, s); :}
                    | CHAR:c
                        {: RESULT = new LiteralExpression<Character> (cleft, cright, c.charAt(0)); :}
                    | TRUE:t
                        {: RESULT = new LiteralExpression<Integer> (tleft, tright, -1); :}
                    | FALSE:f
                        {: RESULT = new LiteralExpression<Integer> (fleft, fright, 0); :}
                    | ID:id OPENPARENTHESIS ExpressionList:elist CLOSEPARENTHESIS
                        {: RESULT = new FunctionCallExpression(idleft, idright, id, elist); :}
                    | ID:id OPENPARENTHESIS CLOSEPARENTHESIS
                        {: RESULT = new FunctionCallExpression(idleft, idright, id, null); :}
                    | OPENPARENTHESIS Expression:exp CLOSEPARENTHESIS
                        {: RESULT = exp; :}
;