import java.io.*;
import java_cup.runtime.*;

action code
{:
    public static String repeat(int count) {
        return repeat(count, "   ");
    }
    public void Print(Tree tree, int depth) {
        System.out.println(repeat(depth) + tree.toString());
        Tree[] children = tree.getChildren();
        if (children != null) {
            for (Tree child : childre) { 
                if (child != null) {
                    Print(child, depth + 1);
                }
            }
        }
    }

:}

parser code
{:
    public void syntax_error(Symbol s){
        report_error("Error sintactico en linea: " + (s.left + 1) + " y columna: " + (s.right + 1) + "\n El simbolo fue: ", sym.terminalNames[s.sym]);
    }

    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception {
        report_fatal_error("Error sintactico fatal: " + s + "\n", null);
    }

:}

terminal COMA, PERIOD;
terminal NOT, AND, OR;
terminal IF, THEN, ELSE, ELSEIF;
terminal DO, LOOP, WHILE;
terminal FOR, TO, NEXT;
terminal MOD;
terminal READLINE, PRINT;
terminal SUB, FUNCTION;
terminal DIM, AS, EQUALTO;
terminal OPENPARENTHESIS, CLOSEPARENTHESIS;
terminal ENDOFLINE;
terminal TRUE, FALSE;
terminal MAIN;
terminal END;
terminal String STRING, ID, TYPE, INTEGER, CHAR;
terminal String RELATIONALOPERATOR, MULTIPLICATIONOPERATOR, ADDITIONOPERATOR;

non terminal Program;
non terminal ModuleListClass PreModuleList, ModuleList;
non terminal FunctionHelper Function;
non terminal ProcedureHelper Procedure;
non terminal ListClass PreArgumentList, ArgumentList;
non terminal ArgumentHelper Argument;
non terminal ListClass PreStatementList, StatementList;
non terminal StatementClass Statement, Loop, IO;
non terminal DeclarationStatement Declaration;
non terminal AssignmentStatement Assignment;
non terminal ListClass ExpressionList;
non terminal Expression Expression;
non terminal FunctionCallStatement FunctionCall;
non terminal ConditionalStatement Conditional, ConditionalElseIf;
non terminal ListClass ConditionalElse;
non terminal ForStatement For;
non terminal WhileStatement While;

precedence left AND, OR;
precedence left RELATIONALOPERATOR;
precedence left ADDITIONOPERATOR;
precedence left MULTIPLICATIONOPERATOR, MOD;
precedence left NOT;


start with Program;

Program ::= PreModuleList:list {: Print(list, 0) :}
;

PreModuleList       ::= SUB:sub MAIN OPENPARENTHESIS CLOSEPARENTHESIS ENDOFLINE PreStatementList:slist END SUB ENDOFLINE ModuleList:mlist 
                        {: RESULT = new ModuleListClass(sub.left, sub.right, mlist, new ProcedureHelper(sub.left, sub.right, "Main", null, slist)); :}
                    | Function:func ENDOFLINE PreModuleList:pmlist
                        {: RESULT = new ModuleListClass(func.line, func.column, pmlist, func); :}
                    | Procedure:proc ENDOFLINE PreModuleList:pmlist
                        {: RESULT = new ModuleListClass(proc.line, proc.column, pmlist, proc); :}
                    | Declaration:dec ENDOFLINE PreModuleList:pmlist
                        {: RESULT = new ModuleListClass(dec.line, dec.column, pmlist, dec); :}
;

ModuleList          ::= Function:func ENDOFLINE ModuleList:mlist
                        {: RESULT = new ModuleListClass(func.line, func.column, mlist, func); :}
                    | Procedure:proc ENDOFLINE ModuleList:mlist
                        {: RESULT = new ModuleListClass(proc.line, proc.column, mlist, proc); :}
                    | Declaration:dec ENDOFLINE ModuleList:mlist
                        {: RESULT = new ModuleListClass(dec.line, dec.column, mlist, dec); :}
                    |
                        {: RESULT = null; :}
;

Function            ::= FUNCTION:func ID:id OPENPARENTHESIS ArgumentList:alist CLOSEPARENTHESIS AS TYPE:type ENDOFLINE PreStatementList:pslist END FUNCTION
                        {: RESULT = new FunctionHelper(func.left, func.right, id, alist, pslist, type); :}
                    | FUNCTION:func ID:id AS TYPE:type ENDOFLINE PreStatementList:pslist END FUNCTION
                        {: RESULT = new FunctionHelper(func.left, func.right, id, null, pslist, type); :}
;

Procedure           ::= SUB:sub ID:id OPENPARENTHESIS ArgumentList:alist CLOSEPARENTHESIS ENDOFLINE PreStatementList:pslist END SUB
                        {: RESULT = new ProcedureHelper(sub.left, sub.right, id, alist, pslist); :}
                    | SUB:sub ID:id ENDOFLINE PreStatementList:pslist END SUB
                        {: RESULT = new ProcedureHelper(sub.left, sub.right, id, null, pslist); :}
;

PreArgumentList     ::= ArgumentList:alist
                        {: RESULT = alist; :}
                    |
                        {: RESULT = null; :}
;

ArgumentList        ::= Argument:arg COMA ArgumentList:alist 
                        {: 
                            alist.Add(arg);
                            RESULT = alist; 
                        :}
                    | Argument:arg
                        {: RESULT = new ListClass<ArgumentHelper> (arg.line, arg.column, arg); :}
;

Argument            ::= ID:id AS TYPE:type
                        {: RESULT = new ArgumentHelper( id.left, id.right, id, type); :}
;

PreStatementList    ::= StatementList:slist
                        {: RESULT = slist :}
                    |
                        {: RESULT = null; :}
;

StatementList       ::= Statement:stat ENDOFLINE StatementList:slist 
                        {: 
                            slist.Add(stat);
                            RESULT = slist; 
                        :}
                    | Statement:stat ENDOFLINE
                        {: RESULT = new ListClass<StatementClass> (stat.line, stat.column, stat); :}
;

FunctionCall        ::= ID:id OPENPARENTHESIS ExpressionList:elist CLOSEPARENTHESIS
                        {: RESULT = new FunctionCallStatement(id.left, id.right, id, elist); :}
                    | ID:id OPENPARENTHESIS CLOSEPARENTHESIS
                        {: RESULT = new FunctionCallStatement(id.left, id.right, id, null); :}
;

Statement           ::= Declaration:dec
                        {: RESULT = dec; :}
                    | Assignment:ass
                        {: RESULT = ass; :}
                    | Conditional:cond
                        {: RESULT = cond; :}
                    | Loop:loo
                        {: RESULT = loo; :}
                    | IO:io
                        {: RESULT = io; :}
                    | FunctionCall:func
                        {: RESULT = func; :}
                    |
                        {: RESULT = null; :}
;

Declaration         ::= DIM:dim ID:id AS TYPE:type
                        {: RESULT = new DeclarationStatement(dim.left, dim.right, id, type); :}
                    | DIM:dim ID:id AS TYPE:type EQUALTO Expression:exp
                        {: RESULT = new DeclarationStatement(dim.left, dim.right, id, type, exp); :}
;

Assignment          ::= ID:id EQUALTO Expression:exp
                        {: RESULT = new AssignmentStatement(id.left, id.right, id, exp); :}
;

IO                  ::= PRINT Expression
                    | READLINE ID
;

Conditional         ::= IF Expression THEN ENDOFLINE PreStatementList ConditionalElseIf ConditionalElse END IF
                    | IF Expression THEN ENDOFLINE PreStatementList ConditionalElseIf END IF
                    | IF Expression THEN ENDOFLINE PreStatementList ConditionalElse END IF
                    | IF Expression THEN ENDOFLINE PreStatementList END IF
;

ConditionalElseIf   ::= ELSEIF Expression THEN ENDOFLINE PreStatementList ConditionalElseIf
                    | ELSEIF Expression THEN ENDOFLINE PreStatementList
;

ConditionalElse     ::= ELSE ENDOFLINE PreStatementList
;

Loop                ::= For 
                    | While
;

For                 ::= FOR Assignment TO INTEGER ENDOFLINE PreStatementList NEXT
;

While               ::= DO ENDOFLINE PreStatementList LOOP WHILE Expression
;

ExpressionList      ::= Expression COMA ExpressionList
                    | Expression
;

Expression          ::= Expression ADDITIONOPERATOR Expression
                    | Expression MULTIPLICATIONOPERATOR Expression
                    | Expression RELATIONALOPERATOR Expression
                    | Expression AND Expression
                    | Expression OR Expression
                    | NOT Expression
                    | ID
                    | INTEGER
                    | STRING
                    | CHAR
                    | ID OPENPARENTHESIS ExpressionList CLOSEPARENTHESIS
                    | ID OPENPARENTHESIS CLOSEPARENTHESIS
                    | TRUE
                    | FALSE
                    | Expression MOD Expression
                    | OPENPARENTHESIS Expression CLOSEPARENTHESIS
;